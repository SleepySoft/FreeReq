"""
The following tables are generated by: https://tableconvert.com/csv-to-ascii

This file includes following class:

+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| Class                   | Usage                                                                   |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| ReqNode                 | The croe data structure for requirement data management.                |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| IReqAgent               | The interface to manage requirement data storage and access.            |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| IReqObserver            | The interface of IReqAgent observer.                                    |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| ReqSingleJsonFileAgent  | The implementation of IReqAgent that supports json file local storage.  |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| ReqModel                | The Model for QTreeView. Adapting IReqAgent to QAbstractItemModel.      |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| ReqEditorBoard          | The UI for Reqirement data editing.                                     |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| ReqMetaBoard            | The UI for Meta data config.                                            |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+
| RequirementUI           | The main UI, includes the TreeView, ReqEditorBoard, ReqMetaBoard        |
+─────────────────────────+─────────────────────────────────────────────────────────────────────────+

The reason of putting all classes in one file:
    1. Only one file to run the basic requirement viewer / editor
    2. You can put this script with your requirement file, without mess file structure
    3. We may add more ReqAgent and UI for FreeReq, but we'll keep this file as the basic requirement viewer / editor.


Resource comments:

+──────────────────────+─────────────────+───────────────────────────────────────────────────────────────────────────+
| Resource             | Type            | Comments                                                                  |
+──────────────────────+─────────────────+───────────────────────────────────────────────────────────────────────────+
| res                  | directory       | The QTreeView style sheet which images that comes from QT official site.  |
+──────────────────────+─────────────────+───────────────────────────────────────────────────────────────────────────+
| MARK_DOWN_CSS_TABLE  | string variant  | The css style sheet. To make Markdown preview looks pretty.               |
+──────────────────────+─────────────────+───────────────────────────────────────────────────────────────────────────+

"""

from __future__ import annotations

import os
import sys
import uuid
import json
import markdown2
import traceback
from functools import partial

try:
    # Use try catch for running FreeReq without UI

    from PyQt5.QtGui import QFont, QCursor
    from PyQt5.QtCore import Qt, QAbstractItemModel, QModelIndex, QSize, QPoint, QItemSelection
    from PyQt5.QtWidgets import qApp, QApplication, QWidget, QHBoxLayout, QVBoxLayout, QGridLayout, \
        QPushButton, QMessageBox, QLabel, QGroupBox, QTableWidget, QTabWidget, QTextEdit, QMenu, \
        QLineEdit, QCheckBox, QComboBox, QTreeView, QInputDialog, QFileDialog
except Exception as e:
    print('UI disabled.')
    print(str(e))
    print(traceback.format_exc())
finally:
    pass

self_path = os.path.dirname(os.path.abspath(__file__))


STATIC_FIELD_ID = 'id'
STATIC_FIELD_UUID = 'uuid'
STATIC_FIELD_TITLE = 'title'
STATIC_FIELD_CHILD = 'child'
STATIC_FIELD_CONTENT = 'content'

STATIC_FIELDS = [STATIC_FIELD_ID, STATIC_FIELD_UUID, STATIC_FIELD_TITLE, STATIC_FIELD_CHILD]


STATIC_META_ID_PREFIX = 'meta_group'


class ReqNode:
    def __call__(self):
        return self

    def __init__(self, title: str = 'New Item'):
        self.__data = {
            STATIC_FIELD_ID: '',
            STATIC_FIELD_UUID: str(uuid.uuid4().hex),
            STATIC_FIELD_TITLE: title,
            STATIC_FIELD_CHILD: [],
            STATIC_FIELD_CONTENT: ''
        }
        self.__parent = None
        self.__sibling = self.__parent.children() if self.__parent is not None else []
        self.__children = []

    # -------------------------------------- Data ---------------------------------------

    def get(self, key: str, default_val: any = None) -> any:
        return self.__data.get(key, default_val)

    def set(self, key: str, val: any):
        if key != STATIC_FIELD_CHILD:
            self.__data[key] = val
        else:
            raise ValueError('The key cannot be "%s"' % STATIC_FIELD_CHILD)

    def data(self) -> dict:
        return self.__data

    def get_uuid(self) -> str:
        return self.__data.get(STATIC_FIELD_UUID, '')

    def set_title(self, text: str):
        self.__data[STATIC_FIELD_TITLE] = text

    def get_title(self) -> str:
        return self.__data.get(STATIC_FIELD_TITLE)

    # ------------------------------------ Property ------------------------------------

    def order(self) -> int:
        if self in self.__sibling:
            return self.__sibling.index(self)
        else:
            print('Warning: Error sibling. It should be a BUG')
            return -1

    def child_count(self) -> int:
        return len(self.__children)

    # ------------------------------------ Iteration ------------------------------------

    def parent(self) -> ReqNode:
        return self.__parent

    def sibling(self) -> [ReqNode]:
        return self.__sibling

    def prev(self) -> ReqNode:
        order = self.order()
        return self.__sibling[order - 1] if order > 0 else None

    def next(self) -> ReqNode:
        order = self.order()
        return self.__sibling[order + 1] if order < len(self.__sibling) else None

    def child(self, order: int):
        return self.__children[order] if 0 <= order < len(self.__children) else None

    def children(self):
        return self.__children

    # ---------------------------------- Construction ----------------------------------

    def set_parent(self, parent: ReqNode):
        self.__parent = parent
        self.__sibling = self.__parent.children() if self.__parent is not None else []

    def append_child(self, node: ReqNode) -> int:
        node.set_parent(self)
        self.__children.append(node)
        return len(self.__children) - 1

    def insert_children(self, node: ReqNode or [ReqNode], pos: int):
        if isinstance(node, ReqNode):
            node = [node]
        for n in node:
            n.set_parent(self)
        self.__children[pos:pos] = node

    def remove_child(self, node: ReqNode) -> bool:
        if node in self.__children:
            self.__children.remove(node)
            return True
        else:
            return False

    def remove_children(self):
        self.__children.clear()

    def insert_sibling_left(self, node: ReqNode) -> int:
        if self.__parent is not None:
            index = self.order()
            self.__parent.insert_children(node, index)
            return index
        else:
            return -1

    def insert_sibling_right(self, node: ReqNode) -> int:
        if self.__parent is not None:
            index = self.order() + 1
            self.__parent.insert_children(node, index)
            return index
        else:
            return -1

    # ------------------------------------ Persists ------------------------------------

    def to_dict(self) -> dict:
        dic = self.__data.copy()
        dic[STATIC_FIELD_CHILD] = [c.to_dict() for c in self.__children]
        return dic

    def from_dict(self, dic: dict):
        self.__data = dic
        self.__children = []
        if STATIC_FIELD_CHILD in dic.keys():
            for sub_dict in dic[STATIC_FIELD_CHILD]:
                node = ReqNode()
                node.from_dict(sub_dict)
                self.append_child(node)
            del self.__data[STATIC_FIELD_CHILD]


# ----------------------------------------------------------------------------------------------------------------------

class IReqObserver:
    def __init__(self):
        pass

    def on_meta_data_changed(self, req_name: str):
        pass

    def on_node_data_changed(self, req_name: str, req_node: ReqNode):
        pass

    def on_node_child_changed(self, req_name: str, req_node: ReqNode):
        pass


class IReqAgent:
    def __init__(self):
        self.__observer: IReqObserver = None

    def init(self, *args, **kwargs) -> bool:
        raise ValueError('Not implemented')

    # ------------------------ Override: Req management -----------------------

    def list_req(self) -> [str]:
        raise ValueError('Not implemented')

    def new_req(self, req_name: str, overwrite: bool = False) -> bool:
        raise ValueError('Not implemented')

    def open_req(self, req_name: str) -> bool:
        raise ValueError('Not implemented')

    def delete_req(self, req_name: str) -> bool:
        raise ValueError('Not implemented')

    # -------------------- Override: After select_op_req() --------------------

    def get_req_name(self) -> str:
        raise ValueError('Not implemented')

    def get_req_meta(self) -> dict:
        raise ValueError('Not implemented')

    def set_req_meta(self, req_meta: dict) -> bool:
        raise ValueError('Not implemented')

    def get_req_root(self) -> ReqNode:
        raise ValueError('Not implemented')

    def get_req_node(self, req_uuid: str) -> ReqNode:
        raise ValueError('Not implemented')

    # ----------------------- Override: Other Functions -----------------------

    def new_req_id(self, id_prefix: str, digit_count: int = 5) -> str:
        raise ValueError('Not implemented')

    # ------------------------ Notification from remote -----------------------

    def inform_node_data_updated(self, req_node: ReqNode):
        pass

    def inform_node_child_updated(self, req_node: ReqNode):
        pass

    # -------------------------------- Observer -------------------------------

    def set_observer(self, ob: IReqObserver):
        self.__observer = ob

    def notify_meta_data_changed(self, req_name: str):
        self.__observer.on_meta_data_changed(req_name)

    def notify_node_data_changed(self, req_name: str, req_node: ReqNode):
        self.__observer.on_node_data_changed(req_name, req_node)

    def notify_node_child_changed(self, req_name: str, req_node: ReqNode):
        self.__observer.on_node_child_changed(req_name, req_node)

    # -------------------------------- Assistant -------------------------------

    @staticmethod
    def req_dict_to_nodes(req_dict: dict) -> ReqNode:
        req_node_root = ReqNode()
        req_node_root.from_dict(req_dict)
        return req_node_root

    @staticmethod
    def req_map(root_node: ReqNode, map_operation) -> dict:
        """
        Iterate all nodes and call map_operation with each node
        :param root_node: The root node you want to iterate since.
        :param map_operation: Callable object.
                            : Declaration: f(node: ReqNode, context: dict)
                            :   node: Current node in iteration.
                            :   context: A dict that pass to map_operation and finally return by req_map()
        :return: The context that passed to map_operation
        """
        context = {}
        IReqAgent.__node_iteration(root_node, map_operation, context)
        return context

    @staticmethod
    def __node_iteration(node: ReqNode, map_operation, context: dict):
        if node is not None:
            map_operation(node, context)
            for child_node in node.children():
                IReqAgent.__node_iteration(child_node, map_operation, context)

    @staticmethod
    def collect_node_information(node: ReqNode) -> dict:
        """
        Collect node information by __node_information_collector()
        :param node: The root node you want to collect from.
        :return: A dict that includes following keys
                    'req_id_conflict' - bool
                    'uuid_instance_table' - dict
                    'req_id_instance_table' - dict
        """
        return IReqAgent.req_map(node, IReqAgent.__node_information_collector)

    @staticmethod
    def __node_information_collector(node: ReqNode, ctx: dict):
        if len(ctx) == 0:
            # Init context
            ctx['req_id_conflict'] = False
            ctx['uuid_instance_table'] = {}
            ctx['req_id_instance_table'] = {}

        _uuid = node.get_uuid().strip()
        req_id = node.get(STATIC_FIELD_ID, '').strip()

        if _uuid != '':
            ctx['uuid_instance_table'][_uuid] = node

        if req_id != '':
            if req_id in ctx['req_id_instance_table'].keys():
                ctx['req_id_conflict'] = True
            ctx['req_id_instance_table'][req_id] = node

    @staticmethod
    def calculate_max_req_id(req_id_prefixes: list, req_id_list: list) -> dict:
        """
        Find the max id for each req id prefix.
        :param req_id_prefixes: The req id prefix list
        :param req_id_list: The req id list of existing nodes
        :return: The dict that groups the max id number by id prefix
        """
        id_prefixes = req_id_prefixes.copy()
        id_prefixes = sorted(id_prefixes, key=len, reverse=True)

        req_id_max = {}
        for req_id in req_id_list:
            for prefix in id_prefixes:
                if req_id.startswith(prefix):
                    try:
                        id_num = int(req_id[len(prefix):])
                        if req_id not in req_id_max.keys():
                            req_id_max[prefix] = id_num
                        else:
                            req_id_max[prefix] = max(id_num, req_id_max[prefix])
                    except Exception as e:
                        print(str(e))
                        continue
                    finally:
                        break
        return req_id_max


# ----------------------------------------------------------------------------------------------------------------------

class ReqSingleJsonFileAgent(IReqAgent):
    def __init__(self, req_path: str = self_path):
        super(ReqSingleJsonFileAgent, self).__init__()
        self.__req_path = req_path
        self.__req_file_name = ''
        self.__req_meta_dict = {}
        self.__req_data_dict = {}
        self.__req_node_root: ReqNode = None

        # Node information
        self.__req_id_max = {}
        self.__uuid_node_index = {}
        self.__req_id_node_index = {}
        self.__collected_information = {}

    def init(self) -> bool:
        return True

    # ----------------------- Req management -----------------------

    def list_req(self) -> [str]:
        req_names = []
        for f in os.scandir(self.__req_path):
            if f.is_file() and f.name.lower().endswith('.req'):
                req_names.append(f.name[:-4])
        return req_names

    def new_req(self, req_name: str, overwrite: bool = False) -> bool:
        if not overwrite and req_name in self.list_req():
            return False
        if req_name.lower().endswith('.req'):
            self.__req_file_name = req_name
        else:
            self.__req_file_name = req_name + '.req'
        self.__req_meta_dict = {}
        self.__req_data_dict = {}
        self.__req_node_root = ReqNode(req_name)
        return True

    def open_req(self, req_name: str) -> bool:
        # if req_name not in self.list_req():
        #     return False
        if req_name.lower().endswith('.req'):
            self.__req_file_name = req_name
        else:
            self.__req_file_name = req_name + '.req'
        return self.__load_req_json()

    def delete_req(self, req_name: str) -> bool:
        return False

    # --------------------- After select_op_req() ---------------------

    def get_req_name(self) -> str:
        return self.__req_node_root.get_title() if self.__req_node_root is not None else ''

    def get_req_meta(self) -> dict:
        return self.__req_meta_dict

    def set_req_meta(self, req_meta: dict) -> bool:
        self.__req_meta_dict = req_meta
        return self.__save_req_json()

    def get_req_root(self) -> ReqNode:
        return self.__req_node_root

    def get_req_node(self, req_uuid: str) -> ReqNode:
        return self.__uuid_node_index.get(req_uuid, None)

    # -------------------------- Other Functions -------------------------

    def new_req_id(self, id_prefix: str, digit_count: int = 5) -> str:
        id_prefixes = self.__req_meta_dict.get(STATIC_META_ID_PREFIX, [])
        if id_prefix in id_prefixes:
            if id_prefix in self.__req_id_max.keys():
                self.__req_id_max[id_prefix] += 1
            else:
                self.__req_id_max[id_prefix] = 1
            format_str = '%%s%%0%dd' % digit_count
            return format_str % (id_prefix, self.__req_id_max[id_prefix])
        else:
            # Unknown prefix
            return id_prefix

    # --------------------- Notification from remote ---------------------

    def inform_node_data_updated(self, req_node: ReqNode):
        self.__save_req_json()

    def inform_node_child_updated(self, req_node: ReqNode):
        self.__save_req_json()

    # -------------------------------------------------------------------------------

    def __load_req_json(self) -> bool:
        try:
            with open(self.__req_file_name, 'rt') as f:
                json_dict = json.load(f)
                self.__req_meta_dict = json_dict.get('req_meta', {})
                self.__req_data_dict = json_dict.get('req_data', {})
                self.__req_node_root = self.req_dict_to_nodes(self.__req_data_dict)
                self.__indexing()
        except Exception as e:
            print(str(e))
            print(traceback.format_exc())
            self.__req_meta_dict = {}
            self.__req_data_dict = {}
            self.__req_node_root = ReqNode('New Requirement')
            return False
        finally:
            pass
        return True

    def __save_req_json(self) -> bool:
        try:
            self.__req_data_dict = self.__req_node_root.to_dict()
            json_dict = {
                'req_meta': self.__req_meta_dict,
                'req_data': self.__req_data_dict
            }

            with open(self.__req_file_name, 'wt') as f:
                json.dump(json_dict, f, indent=4)
        except Exception as e:
            print(str(e))
            print(traceback.format_exc())
            return False
        finally:
            pass
        return True

    def __indexing(self):
        self.__collected_information = IReqAgent.collect_node_information(self.__req_node_root)
        self.__req_id_node_index = self.__collected_information.get('req_id_instance_table', {})
        self.__uuid_node_index = self.__collected_information.get('uuid_instance_table', {})

        id_prefixes = self.__req_meta_dict.get(STATIC_META_ID_PREFIX, [])
        self.__req_id_max = IReqAgent.calculate_max_req_id(id_prefixes, list(self.__req_id_node_index.keys()))


# ----------------------------------------------------------------------------------------------------------------------

class ReqModel(QAbstractItemModel):
    def __init__(self, req_data_agent: IReqAgent):
        super(ReqModel, self).__init__()

        self.__req_data_agent = req_data_agent

    # ------------------------------------- Method -------------------------------------

    def begin_edit(self):
        self.layoutAboutToBeChanged.emit()

    def end_edit(self):
        self.layoutChanged.emit()

    # def set_root_node(self, root_node: ReqNode):
    #     self.__root_node = root_node
    #
    # def get_root_node(self) -> ReqNode:
    #     return self.__root_node

    def index_of_node(self, node: ReqNode) -> QModelIndex:
        return self.createIndex(node.order(), 0, node) if node is not None else QModelIndex()

    @staticmethod
    def get_node_from_index(index: QModelIndex) -> ReqNode:
        return index.internalPointer() if index is not None and index.isValid() else None

    # ------------------------------------ Override ------------------------------------

    def data(self, index: QModelIndex, role=None):
        if index is None or not index.isValid():
            return None

        req_node: ReqNode = index.internalPointer()

        if role == Qt.DisplayRole:
            return req_node.get_title()

        return None

    # def flags(self, index: QModelIndex):
    #     if not index.isValid():
    #         return Qt.NoItemFlags
    #     return super().flags(index)

    # def headerData(self, p_int, orientation: Qt_Orientation, role=None):
    #     if orientation == Qt.Horizontal and role == Qt.DisplayRole:
    #         return self.__root_node.data().get(STATIC_FIELD_TITLE, 'N/A')
    #     return None

    def index(self, row, column, parent: QModelIndex = None, *args, **kwargs):
        if self.__req_data_agent is None or self.__req_data_agent.get_req_root() is None:
            return QModelIndex()

        if parent is None or not parent.isValid():
            parent_item = self.__req_data_agent.get_req_root()
        else:
            parent_item: ReqNode = parent.internalPointer()

        if not QAbstractItemModel.hasIndex(self, row, column, parent):
            return QModelIndex()

        child_item = parent_item.child(row)
        if child_item is not None:
            return QAbstractItemModel.createIndex(self, row, column, child_item)
        return QModelIndex()

    def parent(self, index: QModelIndex = None):
        if self.__req_data_agent is None or self.__req_data_agent.get_req_root() is None:
            return QModelIndex()

        if index is None or not index.isValid():
            return QModelIndex()

        child_item: ReqNode = index.internalPointer()
        parent_item: ReqNode = child_item.parent()

        if parent_item is None:
            return QModelIndex()

        if parent_item == self.__req_data_agent.get_req_root():
            return QAbstractItemModel.createIndex(self, 0, 0, parent_item)
        row = parent_item.order()

        return QAbstractItemModel.createIndex(self, row, 0, parent_item)

    def rowCount(self, parent: QModelIndex = None, *args, **kwargs):
        if self.__req_data_agent is None or self.__req_data_agent.get_req_root() is None:
            return 0

        if parent is None or not parent.isValid():
            parent_item = self.__req_data_agent.get_req_root()
        else:
            parent_item: ReqNode = parent.internalPointer()
        row_count = parent_item.child_count()

        return row_count

    def columnCount(self, parent: QModelIndex = None, *args, **kwargs):
        # if parent.isValid():
        #     return len(parent.internalPointer().data())
        # return len(self.__root_node.data())
        return 1

    def headerData(self, section, orientation, role=0):
        if self.__req_data_agent is None:
            return None

        role = Qt.ItemDataRole(role)
        if role != Qt.DisplayRole:
            return None

        if orientation == Qt.Horizontal:
            return self.__req_data_agent.get_req_name()
        return None

    def insertRow(self, row: int, parent: QModelIndex = None, *args, **kwargs) -> bool:
        return self.insertRows(row, 1, parent)

    def insertRows(self, row: int, count: int, parent=None, *args, **kwargs) -> bool:
        if self.__req_data_agent is None or self.__req_data_agent.get_req_root() is None:
            return False

        if parent is None or not parent.isValid():
            # parent = QModelIndex()
            parent_node: ReqNode = self.__req_data_agent.get_req_root()
        else:
            parent_node: ReqNode = parent.internalPointer()

        self.insert_node_children(parent_node, [ReqNode() for _ in range(count)], row)

        # if row < 0:
        #     row = parent_node.child_count()
        #
        # self.begin_edit()
        # self.beginInsertRows(parent, row, row + count - 1)
        # if parent_node is not None:
        #     parent_node.insert_children([ReqNode() for _ in range(count)], row)
        # self.endInsertRows()
        # self.end_edit()

        return True

    # ---------------------------------- Node Operation ----------------------------------

    def insert_node_children(self, parent_node: ReqNode, insert_nodes: ReqNode or [ReqNode], pos: int):
        if isinstance(insert_nodes, ReqNode):
            insert_nodes = [insert_nodes]
        if parent_node is None:
            parent = QModelIndex()
            parent_node = self.__req_data_agent.get_req_root()
        else:
            parent = self.index_of_node(parent_node)

        if pos < 0:
            pos = parent_node.child_count()

        self.begin_edit()
        self.beginInsertRows(parent, pos, pos + len(insert_nodes) - 1)
        parent_node.insert_children(insert_nodes, pos)
        self.endInsertRows()
        self.end_edit()


# https://gist.github.com/xiaolai/aa190255b7dde302d10208ae247fc9f2

MARK_DOWN_CSS_TABLE = """
.markdown-here-wrapper {
  font-size: 16px;
  line-height: 1.8em;
  letter-spacing: 0.1em;
}


pre, code {
  font-size: 14px;
  font-family: Roboto, 'Courier New', Consolas, Inconsolata, Courier, monospace;
  margin: auto 5px;
}

code {
  white-space: pre-wrap;
  border-radius: 2px;
  display: inline;
}

pre {
  font-size: 15px;
  line-height: 1.4em;
  display: block; !important;
}

pre code {
  white-space: pre;
  overflow: auto;
  border-radius: 3px;
  padding: 1px 1px;
  display: block !important;
}

strong, b{
  color: #BF360C;
}

em, i {
  color: #009688;
}

hr {
  border: 1px solid #BF360C;
  margin: 1.5em auto;
}

p {
  margin: 1.5em 5px !important;
}

table, pre, dl, blockquote, q, ul, ol {
  margin: 10px 5px;
}

ul, ol {
  padding-left: 15px;
}

li {
  margin: 10px;
}

li p {
  margin: 10px 0 !important;
}

ul ul, ul ol, ol ul, ol ol {
  margin: 0;
  padding-left: 10px;
}

ul {
  list-style-type: circle;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 1em;
  font-weight: bold;
  font-style: italic;
}

dl dd {
  margin: 0 0 10px;
  padding: 0 10px;
}

blockquote, q {
  border-left: 2px solid #009688;
  padding: 0 10px;
  color: #777;
  quotes: none;
  margin-left: 1em;
}

blockquote::before, blockquote::after, q::before, q::after {
  content: none;
}

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-style: bold !important;
  color: #009688 !important;
  text-align: center !important;
  margin: 1.5em 5px !important;
  padding: 0.5em 1em !important;
}

h1 {
  font-size: 24px !important;
  border-bottom: 1px solid #ddd !important;
}

h2 {
  font-size: 20px !important;
  border-bottom: 1px solid #eee !important;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}


table {
  padding: 0;
  border-collapse: collapse;
  border-spacing: 0;
  font-size: 1em;
  font: inherit;
  border: 0;
  margin: 0 auto;
}

tbody {
  margin: 0;
  padding: 0;
  border: 0;
}

table tr {
  border: 0;
  border-top: 1px solid #CCC;
  background-color: white;
  margin: 0;
  padding: 0;
}

table tr:nth-child(2n) {
  background-color: #F8F8F8;
}

table tr th, table tr td {
  font-size: 16px;
  border: 1px solid #CCC;
  margin: 0;
  padding: 5px 10px;
}

table tr th {
  font-weight: bold;
  color: #eee;
  border: 1px solid #009688;
  background-color: #009688;
}
"""


class ReqEditorBoard(QWidget):
    def __init__(self, req_data_agent: IReqAgent, req_model: ReqModel):
        super(ReqEditorBoard, self).__init__()

        self.__req_data_agent = req_data_agent
        self.__req_model = req_model
        self.__editing_node: ReqNode = None

        self.__content_edited = False
        self.__meta_data_layouts = []
        self.__meta_data_controls = {}

        self.__line_id = QLineEdit('')
        self.__line_title = QLineEdit('')

        self.__layout_dynamic = QGridLayout()

        self.__text_md_editor = QTextEdit()
        self.__text_md_viewer = QTextEdit()
        self.__group_meta_data = QGroupBox()

        self.__check_editor = QCheckBox('Editor')
        self.__check_viewer = QCheckBox('Viewer')

        self.__button_increase_font = QPushButton('+')
        self.__button_decrease_font = QPushButton('-')

        self.__button_req_refresh = QPushButton('Refresh')
        self.__button_re_assign_id = QPushButton('Re-assign ID')
        self.__button_save_content = QPushButton('Save Content')

        self.__init_ui()

    def __init_ui(self):
        self.__layout_ui()
        self.__config_ui()
        self.__layout_meta_area()

    def __layout_ui(self):
        root_layout = QVBoxLayout()
        self.setLayout(root_layout)

        # up - meta area

        meta_layout = QVBoxLayout()

        static_meta_layout = QHBoxLayout()
        static_meta_layout.addWidget(QLabel('Name: '))
        static_meta_layout.addWidget(self.__line_title, 90)
        static_meta_layout.addWidget(QLabel('  '))
        static_meta_layout.addWidget(QLabel('ID: '))
        static_meta_layout.addWidget(self.__line_id)
        static_meta_layout.addWidget(self.__button_re_assign_id)
        meta_layout.addLayout(static_meta_layout)

        # dynamic_meta_layout = QGridLayout()
        # # TODO: Dynamic create controls by meta data
        meta_layout.addLayout(self.__layout_dynamic)

        self.__group_meta_data.setLayout(meta_layout)
        root_layout.addWidget(self.__group_meta_data, 1)

        # mid

        line = QHBoxLayout()
        line.addWidget(self.__button_increase_font)
        line.addWidget(self.__button_decrease_font)
        line.addWidget(QLabel(''), 99)
        line.addWidget(self.__check_editor)
        line.addWidget(self.__check_viewer)
        line.addWidget(self.__button_save_content)
        root_layout.addLayout(line)

        # down

        edit_area = QHBoxLayout()
        root_layout.addLayout(edit_area, 9)

        edit_area.addWidget(self.__text_md_editor)
        edit_area.addWidget(self.__text_md_viewer)

    def __config_ui(self):
        self.__check_editor.setChecked(True)
        self.__check_viewer.setChecked(True)

        self.__line_id.setReadOnly(True)
        self.__text_md_viewer.setReadOnly(True)

        self.__button_increase_font.setMaximumSize(30, 30)
        self.__button_decrease_font.setMaximumSize(30, 30)

        editor_font = self.__text_md_editor.font()
        editor_font.setPointSizeF(10)
        self.__text_md_editor.setFont(editor_font)
        self.__text_md_viewer.setFont(editor_font)

        self.__check_editor.clicked.connect(self.on_check_editor)
        self.__check_viewer.clicked.connect(self.on_check_viewer)

        self.__line_title.textChanged.connect(self.on_content_changed)
        self.__text_md_editor.textChanged.connect(self.on_text_content_edit)

        self.__button_increase_font.clicked.connect(self.on_button_increase_font)
        self.__button_decrease_font.clicked.connect(self.on_button_decrease_font)

        self.__button_re_assign_id.clicked.connect(self.on_button_re_assign_id)
        self.__button_save_content.clicked.connect(self.on_button_save_content)

    def __layout_meta_area(self):
        self.__reset_layout()
        self.__rebuild_meta_ctrl()
        self.__layout_meta_data_ctrl()

    def __reset_layout(self):
        # https://stackoverflow.com/a/25330164
        for i in reversed(range(self.__layout_dynamic.count())):
            widget_to_remove = self.__layout_dynamic.itemAt(i).widget()
            if widget_to_remove is not None:
                # remove it from the layout list
                self.__layout_dynamic.removeWidget(widget_to_remove)
                # remove it from the gui
                widget_to_remove.setParent(None)

    def __rebuild_meta_ctrl(self):
        meta_data_layouts = []
        meta_data_controls = {}
        meta_data = self.__req_data_agent.get_req_meta()
        for meta_name, meta_selection in meta_data.items():
            if meta_name == STATIC_META_ID_PREFIX:
                continue

            # line = QHBoxLayout()
            # line.addWidget(QLabel(meta_name))
            if len(meta_selection) != 0:
                meta_data_edit_ctrl = QComboBox()
                meta_data_edit_ctrl.addItem('', '')
                meta_data_edit_ctrl.setEditable(False)
                for selection in meta_selection:
                    meta_data_edit_ctrl.addItem(selection, selection)
                meta_data_edit_ctrl.currentTextChanged.connect(self.on_content_changed)
            else:
                meta_data_edit_ctrl = QLineEdit()
                meta_data_edit_ctrl.textChanged.connect(self.on_content_changed)
            # line.addWidget(meta_data_edit_ctrl)

            # meta_data_layouts.append(line)
            meta_data_layouts.append([QLabel(meta_name + ': '), meta_data_edit_ctrl])
            meta_data_controls[meta_name] = meta_data_edit_ctrl

            self.__meta_data_layouts = meta_data_layouts
            self.__meta_data_controls = meta_data_controls

    def __layout_meta_data_ctrl(self):
        count = 0
        config_per_row = 3
        for _label, _input in self.__meta_data_layouts:
            self.__layout_dynamic.addWidget(_label, count // config_per_row, (count % config_per_row) * 2 + 0)
            self.__layout_dynamic.addWidget(_input, count // config_per_row, (count % config_per_row) * 2 + 1)
            count += 1

    def on_check_editor(self):
        self.__text_md_editor.setVisible(self.__check_editor.isChecked())

    def on_check_viewer(self):
        self.__text_md_viewer.setVisible(self.__check_viewer.isChecked())

    def on_button_increase_font(self):
        editor_font = self.__text_md_editor.font()
        font_size = editor_font.pointSizeF()
        editor_font.setPointSizeF(font_size * 1.05)
        self.__text_md_editor.setFont(editor_font)
        self.__text_md_viewer.setFont(editor_font)

    def on_button_decrease_font(self):
        editor_font = self.__text_md_editor.font()
        font_size = editor_font.pointSizeF()
        editor_font.setPointSizeF(font_size / 1.05)
        self.__text_md_editor.setFont(editor_font)
        self.__text_md_viewer.setFont(editor_font)

    def on_button_re_assign_id(self):
        id_prefixes = self.__req_data_agent.get_req_meta().get(STATIC_META_ID_PREFIX, [])

        if len(id_prefixes) == 0:
            QMessageBox.information(self, 'No ID Define', 'Please define the ID prefix in mete data first.')
            return

        if len(id_prefixes) == 1:
            self.on_menu_assign_id(id_prefixes[0])
            self.update_content_edited_status(True)
        else:
            menu = QMenu()
            for id_prefix in id_prefixes:
                menu.addAction(id_prefix, partial(self.on_menu_assign_id, id_prefix))
            menu.exec(QCursor.pos())

    def on_menu_assign_id(self, id_prefix: str):
        req_id = self.__req_data_agent.new_req_id(id_prefix)
        self.__line_id.setText(req_id)
        self.update_content_edited_status(True)

    def on_button_save_content(self):
        if self.__editing_node is not None:
            self.__ui_to_meta_data(self.__editing_node)
            self.__ui_to_req_node_data(self.__editing_node)
        self.update_content_edited_status(False)

    def on_text_content_edit(self):
        md_text = self.__text_md_editor.toPlainText()
        html_text = self.render_markdown(md_text)
        # self.__text_md_viewer.setMarkdown(text)
        self.__text_md_viewer.setHtml(html_text)
        self.on_content_changed()

    def on_content_changed(self, *args):
        self.update_content_edited_status(True)

    # ---------------------------------------------------------------------------

    def __meta_data_to_ui(self, req_node: ReqNode):
        meta_data = self.__req_data_agent.get_req_meta()
        for meta_name, meta_selection in meta_data.items():
            if meta_name == STATIC_META_ID_PREFIX:
                continue

            meta_ctrl = self.__meta_data_controls.get(meta_name, None)
            if meta_ctrl is None:
                print('Warning: Cannot find the control for the meta data.')
                continue

            meta_content = req_node.get(meta_name, '')
            if len(meta_selection) > 1:
                if isinstance(meta_ctrl, QComboBox):
                    index = meta_ctrl.findData(meta_content)
                    if index == -1:
                        print('Warning: Meta content out of meta data selection.')
                        meta_ctrl.setEditable(True)
                        meta_ctrl.setEditText(meta_content)
                    else:
                        meta_ctrl.setEditable(False)
                        meta_ctrl.setCurrentIndex(index)
                else:
                    raise ValueError('The control should be QComboBox')
            else:
                if isinstance(meta_ctrl, QLineEdit):
                    meta_ctrl.setText(meta_content)
                else:
                    raise ValueError('The control should be QLineEdit')

    def __ui_to_meta_data(self, req_node: ReqNode):
        meta_data = self.__req_data_agent.get_req_meta()
        for meta_name, meta_selection in meta_data.items():
            if meta_name == STATIC_META_ID_PREFIX:
                continue

            meta_ctrl = self.__meta_data_controls.get(meta_name, None)
            if meta_ctrl is None:
                print('Warning: Cannot find the control for the meta data.')
                continue

            if isinstance(meta_ctrl, QComboBox):
                meta_content = meta_ctrl.currentText()
            elif isinstance(meta_ctrl, QLineEdit):
                meta_content = meta_ctrl.text()
            else:
                raise ValueError('Warning: The control for meta must be QComboBox or QLineEdit')

            req_node.set(meta_name, meta_content)

    def __req_node_data_to_ui(self, req_node: ReqNode):
        self.__group_meta_data.setTitle('Req UUID: ' + req_node.get_uuid())
        self.__line_title.setText(req_node.get_title())
        self.__line_id.setText(req_node.get(STATIC_FIELD_ID, ''))
        self.__text_md_editor.setText(req_node.get(STATIC_FIELD_CONTENT, ''))

    def __ui_to_req_node_data(self, req_node: ReqNode):
        self.__req_model.begin_edit()
        req_node.set(STATIC_FIELD_ID, self.__line_id.text())
        req_node.set(STATIC_FIELD_TITLE, self.__line_title.text())
        req_node.set(STATIC_FIELD_CONTENT, self.__text_md_editor.toPlainText())
        self.__req_model.end_edit()
        self.__req_data_agent.inform_node_data_updated(req_node)

    def __reset_ui_content(self):
        for _, meta_ctrl in self.__meta_data_controls.items():
            if isinstance(meta_ctrl, QComboBox):
                meta_ctrl.setCurrentIndex(-1)
            elif isinstance(meta_ctrl, QLineEdit):
                meta_ctrl.setText('')
        self.__line_id.setText('')
        self.__line_title.setText('')
        self.__text_md_editor.setText('')
        self.__group_meta_data.setTitle('')

    def update_content_edited_status(self, edited: bool):
        self.__content_edited = edited
        self.__button_save_content.setText('* Save Content' if edited else 'Save Content')

    # ---------------------------------------------------------------------------

    @staticmethod
    def render_markdown(md_text: str) -> str:
        """
        https://zhuanlan.zhihu.com/p/34549578
        :param md_text:
        :return:
        """
        extras = ['code-friendly', 'fenced-code-blocks', 'footnotes', 'tables', 'code-color', 'pyshell', 'nofollow',
                  'cuddled-lists', 'header ids', 'nofollow']

        html_template = """
                <html>
                <head>
                <meta content="text/html; charset=utf-8" http-equiv="content-type" />
                <style>
                    {css}
                </style>
                </head>
                <body>
                    {content}
                </body>
                </html>
                """

        ret = markdown2.markdown(md_text, extras=extras)
        return html_template.format(css=MARK_DOWN_CSS_TABLE, content=ret)

    # ----------------------------------------------------------------------------------

    def edit_req(self, req_node: ReqNode):
        self.__editing_node = req_node
        if req_node is not None:
            self.__meta_data_to_ui(req_node)
            self.__req_node_data_to_ui(req_node)
        else:
            self.__reset_ui_content()
        self.update_content_edited_status(False)

    # def set_data_agent(self, req_data_agent: IReqAgent):
    #     self.edit_req(None)
    #     self.__req_data_agent = req_data_agent

    def is_content_edited(self) -> bool:
        return self.__content_edited

    def on_meta_data_updated(self):
        self.__layout_meta_area()


# ----------------------------------------------------------------------------------------------------------------------

ID_COMMENTS = """
You can specify the prefix of Req ID like: WHY, WHAT, HOW
Then you will get assigned Req ID like WHY00001, WHAT00001, HOW00001
"""


ID_DEFAULT = 'WHY, WHAT, HOW'


META_COMMENTS = """"Meta Name 1": [],
"Meta Name 2": ["Selection 1", "Selection 2"],

Meta Name: The name of config.
Selections: If selection is not empty, the config will be limited with selection, otherwise free input text.
The meta items are divided by comma (,).
"""


META_DEFAULT = """"Owner": [],
"Version": [],
"Status": ["Draft", "Submitted", "Reviewing", "Reserved", "Approved", "Deferred", "Rejected"],
"Priority": ["Must / Vital", "Should / Necessary", "Could / Nice to Have", "To Be Defined"],
"Implementation": ["Not Implemented", "Planing", "Designing", "Implementing", "Verifying", "Full Implemented", "Partial Implemented"]
"""


class ReqMetaBoard(QWidget):
    def __init__(self, req_data_agent: IReqAgent, meta_update_cb=None):
        super(ReqMetaBoard, self).__init__()

        self.__req_data_agent = req_data_agent
        self.__on_meta_data_updated = meta_update_cb

        self.__group_id = QGroupBox('ID Config')
        self.__group_meta = QGroupBox('Meta Data Config')

        self.__button_save = QPushButton('Save')
        self.__button_fill_default_id = QPushButton('Fill Example Value')
        self.__button_fill_default_meta = QPushButton('Fill Example Value')

        self.__text_id_prefixes = QTextEdit(ID_DEFAULT)
        self.__text_meta_defines = QTextEdit(META_DEFAULT)

        self.__init_ui()
        self.reload_meta_data()

    def __init_ui(self):
        self.__layout_ui()
        self.__config_ui()

    def __layout_ui(self):
        root_layout = QVBoxLayout()
        self.setLayout(root_layout)

        root_layout.addWidget(self.__group_id, 2)
        root_layout.addWidget(self.__group_meta, 8)

        group_layout = QVBoxLayout()
        line = QHBoxLayout()
        line.addWidget(QLabel(ID_COMMENTS), 99)
        line.addWidget(self.__button_fill_default_id)
        group_layout.addLayout(line)
        group_layout.addWidget(self.__text_id_prefixes, 99)
        self.__group_id.setLayout(group_layout)

        group_layout = QVBoxLayout()
        line = QHBoxLayout()
        line.addWidget(QLabel(META_COMMENTS), 99)
        line.addWidget(self.__button_fill_default_meta)
        group_layout.addLayout(line)
        group_layout.addWidget(self.__text_meta_defines, 99)
        self.__group_meta.setLayout(group_layout)

        line = QHBoxLayout()
        line.addStretch(100)
        line.addWidget(self.__button_save)

        root_layout.addLayout(line)

    def __config_ui(self):
        self.__button_save.clicked.connect(self.on_button_save)
        self.__button_fill_default_id.clicked.connect(self.on_button_fill_default_id)
        self.__button_fill_default_meta.clicked.connect(self.on_button_fill_default_meta)

    def on_button_save(self):
        if self.__req_data_agent is None:
            return

        try:
            meta_data = self.__ui_to_meta()
        except Exception as e:
            print(str(e))
            meta_data = None
            QMessageBox.information(self, 'Parse Meta Data Fail',
                                    'Parse Meta Data Fail. Please check the format')
        finally:
            pass

        if meta_data is not None:
            self.__req_data_agent.set_req_meta(meta_data)
            if self.__on_meta_data_updated is not None:
                self.__on_meta_data_updated()

    def on_button_fill_default_id(self):
        self.__text_id_prefixes.setText(ID_DEFAULT)

    def on_button_fill_default_meta(self):
        self.__text_meta_defines.setText(META_DEFAULT)

    def reload_meta_data(self):
        self.__meta_to_ui()

    # def set_data_agent(self, req_data_agent: IReqAgent):
    #     self.__req_data_agent = req_data_agent
    #     self.reload_meta_data()

    # ----------------------------------------------------------------------

    def __meta_to_ui(self):
        if self.__req_data_agent is not None:
            meta_data = self.__req_data_agent.get_req_meta()
            meta_data = meta_data.copy()

            if STATIC_META_ID_PREFIX in meta_data.keys():
                id_prefix = meta_data[STATIC_META_ID_PREFIX]
                del meta_data[STATIC_META_ID_PREFIX]
            else:
                id_prefix = []

            id_prefix_text = ', '.join(id_prefix)

            # meta_data_text = json.dumps(meta_data, indent=4)
            # meta_data_text = meta_data_text.strip('{}')

            meta_data_lines = []
            for meta_name, meta_selection in meta_data.items():
                selection_text = ', '.join(['"%s"' % s for s in meta_selection])
                meta_data_lines.append('"%s": [%s]' % (meta_name, selection_text))
            meta_data_text = ', \n'.join(meta_data_lines)

            self.__text_id_prefixes.setText(id_prefix_text)
            self.__text_meta_defines.setText(meta_data_text)

    def __ui_to_meta(self) -> dict:
        id_prefix_text = self.__text_id_prefixes.toPlainText()
        meta_data_text = self.__text_meta_defines.toPlainText()

        id_prefix = id_prefix_text.split(',')
        id_prefix = [_id.strip() for _id in id_prefix]

        meta_data = json.loads('{' + meta_data_text + '}')
        meta_data[STATIC_META_ID_PREFIX] = id_prefix

        return meta_data


# ----------------------------------------------------------------------------------------------------------------------

class RequirementUI(QWidget):
    def __init__(self, req_data_agent: IReqAgent):
        super(RequirementUI, self).__init__()

        self.__req_data_agent = req_data_agent
        self.__req_model = ReqModel(self.__req_data_agent)

        self.__cut_items = []
        self.__selected_node: ReqNode = None
        self.__selected_index: QModelIndex = None

        self.__combo_req_select = QComboBox()
        self.__tree_requirements = QTreeView()

        self.__button_req_refresh = QPushButton('Refresh')

        self.__edit_tab = QTabWidget()
        self.__meta_board = ReqMetaBoard(self.__req_data_agent, self.__on_meta_data_updated)
        self.__edit_board = ReqEditorBoard(self.__req_data_agent, self.__req_model)

        self.__init_ui()

    def __init_ui(self):
        self.__layout_ui()
        self.__config_ui()

    def __layout_ui(self):
        root_layout = QHBoxLayout()
        self.setLayout(root_layout)

        left_area = QVBoxLayout()
        root_layout.addLayout(left_area)
        root_layout.addWidget(self.__edit_tab, 99)
        root_layout.addWidget(self.__edit_board, 99)

        # ------------------------- Left area ------------------------

        line = QHBoxLayout()
        line.addWidget(self.__combo_req_select)
        line.addWidget(self.__button_req_refresh)
        left_area.addLayout(line)
        left_area.addWidget(self.__tree_requirements)

        # ------------------------ Right area ------------------------

        self.__edit_tab.addTab(self.__edit_board, 'Requirement Edit')
        self.__edit_tab.addTab(self.__meta_board, 'Meta Config')

    def __config_ui(self):
        self.setMinimumSize(800, 600)
        self.setWindowTitle('Free Requirement - by Sleepy')

        self.__tree_requirements.setModel(self.__req_model)
        self.__tree_requirements.setAlternatingRowColors(True)
        self.__tree_requirements.setContextMenuPolicy(Qt.CustomContextMenu)

        try:
            # QTreeView style From: https://doc.qt.io/qt-6/stylesheet-examples.html
            with open(os.path.join(self_path, 'res', 'tree_style.qss'), 'rt') as f:
                tree_style = f.read()
                self.__tree_requirements.setStyleSheet(tree_style)
        except Exception as e:
            print(str(e))
            print('QTreeView style not applied.')
        finally:
            pass

        self.__button_req_refresh.clicked.connect(self.on_button_req_refresh)

        self.__tree_requirements.setModel(self.__req_model)
        self.__tree_requirements.clicked.connect(self.on_requirement_tree_click)
        self.__tree_requirements.customContextMenuRequested.connect(self.on_requirement_tree_menu)
        self.__tree_requirements.selectionModel().selectionChanged.connect(self.on_requirement_tree_selection_changed)

    def on_button_req_refresh(self):
        pass

    def on_requirement_tree_click(self, index: QModelIndex):
        pass
        # self.__update_selected_index(index)
        # if index.isValid():
        #     req_node: ReqNode = index.internalPointer()
        #     self.__selected_node = req_node
        #     self.__selected_index = index
        #     self.__edit_board.edit_req(req_node)

    def on_requirement_tree_menu(self, pos: QPoint):
        menu = QMenu()
        sel_index: QModelIndex = self.__tree_requirements.indexAt(pos)
        if sel_index is not None and sel_index.isValid():
            # self.__update_selected_index(sel_index)
            # self.__selected_index = sel_index
            # self.__selected_node = self.__req_model.get_node_from_index(sel_index)

            menu.addAction('Append Child', self.on_requirement_tree_menu_append_child)
            menu.addSeparator()
            menu.addAction('Insert sibling up', self.on_requirement_tree_menu_add_sibling_up)
            menu.addAction('Insert sibling down', self.on_requirement_tree_menu_add_sibling_down)
            menu.addSeparator()
            menu.addAction('Shift item up', self.on_requirement_tree_menu_shift_item_up)
            menu.addAction('Shift item Down', self.on_requirement_tree_menu_shift_item_down)
            menu.addSeparator()
            if len(self.__cut_items) > 0:
                menu.addAction('Paste Item as child', partial(self.on_requirement_tree_menu_paste_item, 'child'))
                menu.addAction('Paste Item as up sibling', partial(self.on_requirement_tree_menu_paste_item, 'up'))
                menu.addAction('Paste Item as down sibling', partial(self.on_requirement_tree_menu_paste_item, 'down'))
            menu.addAction('Cut item', self.on_requirement_tree_menu_cut_item)
            menu.addSeparator()
            menu.addAction('Delete item (Caution!!!)', self.on_requirement_tree_menu_delete_item)

        else:
            # self.__update_selected_index(None)

            menu.addAction('Add New Top Item', self.on_requirement_tree_menu_add_top_item)
            if len(self.__cut_items) > 0:
                menu.addAction('Paste as Top Item', partial(self.on_requirement_tree_menu_paste_item, 'top'))
            menu.addSeparator()
            menu.addAction('Rename Requirement', self.on_requirement_tree_menu_rename_req)
            menu.addSeparator()
            menu.addAction('Create a New Requirement', self.on_requirement_tree_menu_create_new_req)
            menu.addSeparator()
            menu.addAction('Open Local Requirement File', self.on_requirement_tree_menu_open_local_file)
        menu.exec(QCursor.pos())

    def on_requirement_tree_selection_changed(self, selected: QItemSelection, deselected: QItemSelection):
        if self.__selected_node is not None and self.__edit_board.is_content_edited():
            ret = QMessageBox.question(self, 'Save or Not',
                                       'Requirement Content Changed.\r\nSave?',
                                       QMessageBox.Yes | QMessageBox.No)
            if ret == QMessageBox.Yes:
                self.__edit_board.on_button_save_content()

        selected_indexes = selected.indexes()
        if len(selected_indexes) > 0:
            selected_index = selected_indexes[0]
            self.__update_selected_index(selected_index)

    def on_requirement_tree_menu_add_top_item(self):
        self.__req_model.insertRow(-1)
        self.__req_data_agent.inform_node_child_updated(self.__req_data_agent.get_req_root())

        # req_root = self.__req_data_agent.get_req_root()
        # if req_root is not None:
        #     new_node = ReqNode('New Top Item')
        #     self.__req_model.begin_edit()
        #     req_root.append_child(new_node)
        #     self.__req_model.end_edit()
        #     self.__req_data_agent.inform_node_data_updated(req_root)

    def on_requirement_tree_menu_append_child(self):
        if self.__tree_item_selected():
            selected_node = self.__selected_node
            self.__req_model.insertRow(-1, self.__selected_index)
            # new_node = ReqNode('New Item')
            # parent_node = self.__req_model.parent(self.__selected_index)
            # append_pos = self.__selected_node.child_count()
            # self.__req_model.beginInsertRows(parent_node, append_pos, append_pos)
            # self.__selected_node.append_child(new_node)
            # self.__req_model.endInsertRows()
            self.__req_data_agent.inform_node_child_updated(selected_node.parent())

    def on_requirement_tree_menu_add_sibling_up(self):
        if self.__tree_item_selected():
            # new_node = ReqNode('New Item')
            # parent_node = self.__req_model.parent(self.__selected_index)

            selected_node = self.__selected_node
            insert_pos = self.__selected_node.order()
            parent_index = self.__req_model.parent(self.__selected_index)
            self.__req_model.insertRow(insert_pos, parent_index)

            # self.__req_model.beginInsertRows(parent_node, insert_pos - 1, insert_pos)
            # self.__selected_node.insert_sibling_left(new_node)
            # self.__req_model.endInsertRows()
            self.__req_data_agent.inform_node_child_updated(selected_node.parent())

    def on_requirement_tree_menu_add_sibling_down(self):
        if self.__tree_item_selected():
            # new_node = ReqNode('New Item')
            # parent_node = self.__req_model.parent(self.__selected_index)

            selected_node = self.__selected_node
            insert_pos = self.__selected_node.order() + 1
            parent_index = self.__req_model.parent(self.__selected_index)
            self.__req_model.insertRow(insert_pos, parent_index)

            # self.__req_model.beginInsertRows(parent_node, insert_pos, insert_pos)
            # self.__selected_node.insert_sibling_right(new_node)
            # self.__req_model.endInsertRows()
            self.__req_data_agent.inform_node_child_updated(selected_node.parent())

    def on_requirement_tree_menu_shift_item_up(self):
        if self.__tree_item_selected():
            selected_node = self.__selected_node
            node_order = self.__selected_node.order()
            sibling_list = self.__selected_node.sibling()
            # parent_index = self.__req_model.parent(self.__selected_index)
            if node_order > 0:
                # self.__req_model.beginMoveRows(parent_index, node_order - 1, node_order,
                #                                parent_index, node_order)
                self.__req_model.begin_edit()
                sibling_list[node_order - 1], sibling_list[node_order] = \
                    sibling_list[node_order], sibling_list[node_order - 1]
                self.__req_model.end_edit()
                # self.__req_model.endMoveRows()
            self.__req_data_agent.inform_node_child_updated(selected_node.parent())

    def on_requirement_tree_menu_shift_item_down(self):
        if self.__tree_item_selected():
            selected_node = self.__selected_node
            node_order = self.__selected_node.order()
            sibling_list = self.__selected_node.sibling()
            # parent_index = self.__req_model.parent(self.__selected_index)
            if node_order + 1 < len(sibling_list):
                # self.__req_model.beginMoveRows(parent_index, node_order, node_order + 1,
                #                                parent_index, node_order)
                self.__req_model.begin_edit()
                sibling_list[node_order + 1], sibling_list[node_order] = \
                    sibling_list[node_order], sibling_list[node_order + 1]
                self.__req_model.end_edit()
                # self.__req_model.endMoveRows()
            self.__req_data_agent.inform_node_child_updated(selected_node.parent())

    def on_requirement_tree_menu_cut_item(self):
        if self.__tree_item_selected():
            self.__cut_items.append(self.__selected_node)
            self.on_requirement_tree_menu_delete_item()

    def on_requirement_tree_menu_paste_item(self, pos: str):
        if pos == 'top' or self.__tree_item_selected():
            if len(self.__cut_items) > 0:
                paste_node = self.__cut_items.pop()

                if pos == 'top':
                    parent_node = self.__req_data_agent.get_req_root()
                elif pos == 'child':
                    parent_node = self.__selected_node
                else:
                    parent_node = self.__selected_node.parent()

                if pos in ['top', 'child']:
                    self.__req_model.insert_node_children(parent_node, paste_node, -1)
                elif pos == 'up':
                    paste_pos = self.__selected_node.order()
                    self.__req_model.insert_node_children(parent_node, paste_node, paste_pos)
                elif pos == 'down':
                    paste_pos = self.__selected_node.order() + 1
                    self.__req_model.insert_node_children(parent_node, paste_node, paste_pos)

                self.__req_data_agent.inform_node_child_updated(parent_node)

    def on_requirement_tree_menu_delete_item(self):
        if self.__tree_item_selected():
            selected_node = self.__selected_node
            node_order = self.__selected_node.order()
            node_parent = self.__selected_node.parent()
            if node_parent is not None:
                # Because beginRemoveRows() will change the selected node

                self.__req_model.beginRemoveRows(
                    self.__req_model.parent(self.__selected_index), node_order, node_order + 1)
                node_parent.remove_child(selected_node)
                self.__req_model.endRemoveRows()
                self.__req_data_agent.inform_node_child_updated(node_parent)

                # self.__update_selected_index(None)

    def on_requirement_tree_menu_rename_req(self):
        req_name, is_ok = QInputDialog.getText(
            self, "Rename Requirement", "Requirement Name: ", QLineEdit.Normal, "")
        req_name = req_name.strip()
        if is_ok and req_name != '':
            node_root = self.__req_data_agent.get_req_root()
            if node_root is not None:
                node_root.set_title(req_name)
                self.__req_data_agent.inform_node_data_updated(node_root)

    def on_requirement_tree_menu_create_new_req(self):
        req_name, is_ok = QInputDialog.getText(
            self, "Create New Requirement", "Requirement Name: ", QLineEdit.Normal, "")
        req_name = req_name.strip()
        if is_ok and req_name != '':
            if req_name in self.__req_data_agent.list_req():
                ret = QMessageBox.question(
                    self, 'Overwrite', 'Requirement already exists.\n\nOverwrite?',
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if ret != QMessageBox.Yes:
                    return

            self.__req_model.beginRemoveRows(QModelIndex(), 0, 0)
            self.__req_data_agent.new_req(req_name, overwrite=True)
            self.__req_model.endRemoveRows()

            self.__edit_board.edit_req(None)
            self.__meta_board.reload_meta_data()

            # req_root = self.__req_data_agent.get_req_root()
            # self.__req_model.begin_edit()
            # self.__root_node.append_child(req_root)
            # self.__req_model.end_edit()

    def on_requirement_tree_menu_open_local_file(self):
        file_path, is_ok = QFileDialog.getOpenFileName(
            self, 'Select File', '', 'Requirement File (*.req);;All files (*.*)')
        if is_ok:
            self.__req_model.beginRemoveRows(QModelIndex(), 0, 0)
            self.__req_data_agent.open_req(file_path)
            self.__req_model.endRemoveRows()

            self.__edit_board.edit_req(None)
            self.__meta_board.reload_meta_data()

            # req_agent = ReqSingleJsonFileAgent()
            # req_agent.init()
            # req_agent.open_req(file_path)
            # req_model = ReqModel(req_agent)
            #
            # self.__req_data_agent = req_agent
            # self.__req_model = req_model

            # self.__update_req_tree()

    # def __update_req_tree(self):
    #     self.__tree_requirements.setModel(self.__req_model)

    def __tree_item_selected(self) -> bool:
        return self.__selected_index is not None and \
               self.__selected_index.isValid() and \
               self.__selected_node is not None

    def __update_selected_index(self, index: QModelIndex or None):
        if index is not None and index.isValid():
            req_node: ReqNode = index.internalPointer()
            self.__selected_node = req_node
            self.__selected_index = index
            self.__edit_board.edit_req(req_node)
        else:
            self.__selected_node = None
            self.__selected_index = None
            self.__edit_board.edit_req(None)
        # print('Select Node:　' + str(self.__selected_node))

    def __on_meta_data_updated(self):
        self.__edit_board.on_meta_data_updated()


# ---------------------------------------------------------------------------------------------------------------------

def main():
    app = QApplication(sys.argv)

    req_agent = ReqSingleJsonFileAgent()
    req_agent.init()
    if not req_agent.open_req('FreeReq'):
        req_agent.new_req('FreeReq', True)
    w = RequirementUI(req_agent)

    w.show()
    sys.exit(app.exec_())


# ----------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print('Error =>', e)
        print('Error =>', traceback.format_exc())
        exit()
    finally:
        pass
